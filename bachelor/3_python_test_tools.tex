% !TeX root = ../bachelor.tex
\section{Python Test-Tools}\label{python-tools}

Dieses Kapitel befasst sich mit den von der STDLIB bereitgestellten Test-Tools
sowie denen aus externen Paketen.
Diese werden unter \ref{python-tools:stdlib} und \ref{python-tools:extlib}
zusammengefasst, wobei diese unterteilt sind in unit-testing -,
\gls{mock}-testing - und \gls{fuzz} Tools.

Die unit-testing Tools sind Tools die Funktionalität zum testen bereitstellen.
Jedoch wird für TDD weit mehr als nur Tests benötigt, aus diesem Grund werden
\gls{mock}-testing - und \gls{fuzz} Tools zusätzlich behandelt. Dabei soll aber
zwischen einer reinen Erweiterung eines Tools und der Erweiterung von allen Tools
unterschieden werden.
Ist zum Beispiel ein Tool nur zusammen mit einem anderen Tool, das die Funktionalität
bereit stellt Tests aus zu führen, so ist dieses Tool als Erweiterung zu sehen. Bietet
ein Tool allerdings Code zum Erweitern von verschiedenen Test Tools zur Verfügung, so
wird es hier zur Analyse verwendet.
Diese Unterscheidung wird verwendet um Duplikationen in den einzelnen vergleichen zu
vermeiden, des weiteren gibt es Tools mit x Erweiterungen, diese alle zu vergleichen würde
den Rahmen dieser Arbeit bei weitem sprengen.
Sollten sich für ein Tool besonders interessante Erweiterungen finden, so werden diese
in der Analyse des jeweiligen Tools erwähnt und verlinkt.
\newline
\\
Jedes Tool wird anhand folgender Aspekte untersucht:
\begin{itemize}
    \item \underline{Anwendbarkeit}:\newline
    Bietet das Tool alles, um TDD betreiben zu können? (\Glspl{fixture} und \Glspl{mock})
    Mit wie vielen Paketen muss das Tool betrieben werden? (Mehr Abhängigkeiten führen zu
    mehr externe Entwicklern auf die man sich verlassen muss.)
    \begin{itemize}
        \item Bei \gls{mock}-testing- und \gls{fuzz}-testing-Tools wird hier auf die
        Features die das jeweilige Tool bietet geprüft.
    \end{itemize}
    
    \item \underline{Effizienz}:\newline
    Wie viel lässt sich mit diesem Tool möglichst einfach und
    schnell erreichen? Ist besonders viel Vorarbeit notwendig um die Tests
    auf zu setzen oder kann sofort mit dem Schreiben der Tests begonnen
    werden?
    \newline
    Genauso stellt sich die Frage, wie Effizient der Entwickler die Tests
    auswerten kann (Nur bei Tools mit test-runner).
    
    \item \underline{Komplexität}:\newline
    Wie komplex ist das Tool? Das heißt, wie viel Funktionalität
    bietet das Tool dem Entwickler von Haus aus, aber auch wie schwer
    ist es einen Code zu schreiben oder wie schnell wird ein Code unübersichtlich, da
    das Tool viel Code abseits der Tests benötigt.
    
    \item \underline{Erweiterbarkeit}:\newline
    Wie leicht lässt sich das Tool mit anderen Tools erweitern?
    Gibt es vielleicht Erweiterungen der Community für dieses Tool, die sehr
    hilfreich sind?
    \begin{itemize}
        \item Dieser Punkt wird bei \gls{mock}-testing - und \gls{fuzz}-testing Tools ignoriert,
        da diese selbst Erweiterungen darstellen.
    \end{itemize}
\end{itemize}
\noindent
Zum Vergleich der einzelnen unit-testing Tools untereinander werden sie auf den in Listing
\ref{listing:base:my_module} abgebildeten Code angewandt, da sich diese Arbeit auch mit
\gls{mock}-testing - und \gls{fuzz}-testing Tools beschäftigt wurden auch für diese
Code geschrieben der zu testen ist. Der Code für die \gls{mock}-testing Tools befindet sich
in Listing \ref{listing:base:my_mock_module} und der für \gls{fuzz}-testing in Listing
\ref{listing:base:my_fuzz_module}. Dadurch lassen sich die unterschiedlichen Anforderungen
zwischen den Arten der Tools besser vergleichen.

Das Modul für unit-testing enthält eine selbst geschriebene Implementierung der Funktion \lstinline|pow()|,
welche eine Zahl \lstinline|a| mit einer Zahl \lstinline|b| quadriert. Um die Komplexität
zu erhöhen wurde eine in-memory Datenbank implementiert, welche Items enthält. Jedes Item 
hat eine ID (\lstinline|id|), einen Namen (\lstinline|name|), einen Lager Platz
(\lstinline|storage_location|) und eine Anzahl der vorrätigen Items \lstinline|amount|.
Jedes Item besitzt zudem eine Methode \lstinline|do_something()| welche eine externe
Funktion/Methode aufruft, die jedoch noch nicht existiert
\lstinline|do_something_which_does_not_exist()|.

Für die \gls{mock}-testing Tools wurde eine Klasse geschrieben, welche Funktionen besitzt
die in ihrem Namen ausdrücken welche Methode sie ausführen, jedoch macht nicht jede Methode
das was sie soll. Die \gls{mock}-testing Tools sollen hier die Methoden so \gls{mock}en, dass
sie das jeweilige ausführen. Selbstverständlich ist realer Code viel komplexer als in diesem
Listing (\ref{listing:base:my_mock_module}) dargestellt, jedoch reicht dieser Code aus um viele
Tools an Ihre grenzen zu bringen. So muss in \lstinline{call_internal_functin_n_times} überprüft
werden ob sie \lstinline{n} mal aufgerufen wurde, auch \lstinline{call_helper_help} wird nicht
ohne weiteres funktionieren, da die Klasse \lstinline{Helper} noch nicht implementiert wurde
(Was in TDD sehr oft der Fall sein wird). Auch die Methode \lstinline{return_false_filepath}
bringt das ein oder andere Tool zum schwitzen, da eine externe Methode aus der STDLIB ersetzt
werden muss, wobei dies nicht global geschehen darf.

TODO fuzzetsting

Verfügt ein Tool über keinen test-runner, so wird der von der STDLIB gestellte runner
\lstinline{unittest} verwendet.

\input{bachelor/3_1_stdlib}
\input{bachelor/3_2_extlib}


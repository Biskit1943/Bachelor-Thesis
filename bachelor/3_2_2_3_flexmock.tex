% !TeX root = ../bachelor.tex
\paragraph{flexmock}\label{python-tools:flexmock}\mbox{}
\newline
\lstinline{flexmock} ist ein weiteres Tool, dass von der Ruby Community
inspiriert wurde. Dabei diente das gleichnamige Tool
\href{https://github.com/jimweirich/flexmock}{flexmock}\footnote{https://github.com/jimweirich/flexmock}
als Inspiration. "`[...]. Es ist jedoch nicht das Ziel von Python flexmock, ein
Klon der Ruby-Version zu sein. Stattdessen liegt der Schwerpunkt auf der
vollständigen Unterstützung beim Testen von Python-Programmen und der möglichst
unauffälligen Erstellung von gefälschten Objekten."'\footnote{Übersetzt aus dem Englischen}
(\cite{flexmock:docs:0.10.3}). Die Features von \lstinline{flexmock} sind denen
von \nameref{python-tools:mocktest} sehr ähnlich. So bildet \lstinline{flexmock}
seine Tests, \glspl{stub} und \glspl{mock} wie ausgesprochen dar.
\newline

\lstinline{flexmock} bietet dem Nutzer einiges an Funktionalität, auch wenn es
sich erst in der Version \lstinline{0.10.4} (Stand 22. April 2019) befindet. So
lässt sich bereits ein \Gls{stub} für Klassen, Module und Objekte mithilfe von
\lstinline{flexmock()} einrichten. Damit ist es möglich alles was ein Entwickler
zum erfolgreichen durchlaufen seiner Tests brauch zu erstellen.

Auch \gls{mock}ing ist kein Problem mit \lstinline{flexmock}. Mit der gleichen
Funktion, mit der auch \Glspl{stub} erstellt werden lassen sich auch
\Glspl{mock} erstellen. Dadurch ist es möglich, einen \Gls{stub} als einen
\Gls{mock} und umgekehrt zu verwenden. Daraus resultierend ist es dem
Entwickler möglich zu überprüfen wie oft etwas aufgerufen wurde, welche
Parameter verwendet wurden, welcher Rückgabe Wert zu erwarten ist und/oder
welche Exception zu geworfen werden soll.

Zusätzlich ist es möglich originale Funktionen eines Objektes zu
\gls{mock}en, dadurch enthält der Entwickler die Möglichkeit
zu überprüfen ob eine unveränderte Funktion oder Methode bestimmten
Anforderungen Entspricht. Das Interface dafür, ist das gleiche wie bei einem
\Gls{stub}.

\lstinline{flexmock} bietet des weiteren Funktionalität um den gefälschten
Objekten neue Methoden hinzu zu fügen, wodurch nicht existierende Funktionen
abgebildet werden können oder Objekte in ihrem Funktionsumfang temporär
erweitert werden können.
\newline

Ein besonders interessantes Feature ist, dass überprüfen des Ergebnisses nach
Typ. Dabei wird \lstinline{.and_return()} nur der Typ mitgegeben, der erwartet
wird. So würde
\\% Code geht über Zeile hinaus
\lstinline{.and_return((int, str, None)} jedes \lstinline{Tuple}
zulassen, dass als ersten Wert einen \lstinline{int} hat, als zweiten einen
String und als drittes None. Dabei kann selbstverständlich auf jede beliebige
Instanz überprüft werden, so auch auf eigene Klassen. Dies ist allerdings nur
möglich bei \lstinline{.should_call()} nicht bei \lstinline{.should_receive()}.

Das letzte in der Dokumentation erwähnte Feature ist das ersetzen von Klassen
noch vor ihrer Instanziierung (\cite{flexmock:docs:0.10.3}). Dabei gibt es
mehrere Ansätze die allerdings auch verschiedene Ausgänge haben, der erste ist
auf Modul Level, dabei wird im Modul die Klasse mit einem Objekt ersetzt, dass
entweder ein \lstinline{flexmock} sein kann oder ein Beliebig anderes. Der
Nachteil dieser Methode ist, dass es eventuell zu Problemen führen kann, dass
die Klasse durch eine Funktion ersetzt wurde. Die alternative ist,
\lstinline{.new_instance(obj)} zu verwenden, welches beim erstellen das Objekt
zurück gibt, welches \lstinline{.new_instnce()} übergeben wurde oder man ersetzt
die \lstinline{__new__()} Methode der Klasse mit
\lstinline{.should_receive('__new__').and_return(obj)} was im Endeffekt das
gleiche ist, nur ausgeschrieben.
\newline

Der Code zu Listing \ref{listing:base:my_mock_module} wurde mithilfe des Codes
von \lstinline{flexmock} getestet, dabei ergaben sich die eben aufgelisteten
Eigenschaften (vgl. Listing \ref{listing:flexmock:example}).
\lstinline{flexmock} überzeugt dabei mit der Einfachheit mit der es aufgesetzt
werden muss. In der \lstinline{setUp()} wird global im Modul
\lstinline{my_package.my_mock_module} die Klasse \lstinline{NotMocked} ersetzt.
Dadurch ist ex möglich in jedem Test Fall eine Annahme auf zu stellen, die dann
auf alle Objekte der Klasse \lstinline{NotMocked} zutreffen. Der aufwand diesen
Code zu schreiben war demnach sehr gering. Lediglich das erstellen einer
Methode die im Originalen Objekt nicht existiert war nicht möglich, aus diesem
Grund ist der Code in \lstinline{test_call_helper_help()} nicht korrekt und
wirft eine Exception, diese kann in Listing \ref{listing:flexmock:exception}
eingesehen werden.
\newline

Die Anwendbarkeit von \lstinline{flexmock} ist ausgezeichnet, da es zunächst
keine weiteren Abhängigkeiten installiert außer sich selbst und mit allen
Test-runnern kompatibel ist. Im Bezug auf TDD lässt \lstinline{flexmock} nichts
zu wünschen übrig, dem Entwickler werden allerhand Funktionalität geboten
\Glspl{stub} oder \Glspl{mock} zu erstellen und zu verwenden. Dabei lässt sich
alles überprüfen von der Aufruf Anzahl bis zu den Parametern die verwendet
wurden.

Im Aspekt Effizienz ist \lstinline{flexmock} ein Parade-Beispiel, einmal
\lstinline{flexmock()} aufgerufen kann bereits los gelegt werden, dabei muss der
Entwickler selbst wenig von \gls{mock}ing verstehen um die Funktionalität nutzen
zu können, da sich der Code wie eine Aussage ließt. Das gleiche gilt natürlich
auch für die \Glspl{stub}.

Genauso ist die Komplexität von \lstinline{flexmock} ausgezeichnet. An
Funktionalität bietet \lstinline{flexmock} fast alles was sich ein Entwickler
wünschen kann und bietet dabei auch noch ein Interface, dass es ermöglicht
übersichtlichen Code zu schreiben. Dies liegt vor allem an der deskriptiven
Programmierung die von \lstinline{flexmock} geboten wird. Unübersichtlich
wird dadurch der Code nicht mehr als er im laufe der Zeit sowieso werden würde,
eher noch hilft \lstinline{flexmock} dabei die Übersicht länger zu wahren.
Lediglich das ersetzen einer nicht Existenten Funktion/Methode war mit
\lstinline{flexmock} nicht möglich.
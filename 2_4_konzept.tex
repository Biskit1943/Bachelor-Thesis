% !TeX root = ../expose.tex
\section{Konzept}
Die Test-Tools aus der Standard Bibliothek von Python, sowie die beliebtesten
Test-Tools, werden anhand folgender Aspekte verglichen:

\begin{itemize}
    \item Anwendbarkeit
        \subitem Bietet das Tool alles, um TDD betreiben zu können? (Bei TDD
        kann man Tests \gls{mocken}, wodurch sie nicht fehlschlagen.)
        Mit wie vielen Packeten muss das Tool betrieben werden?
    \item Effizienz
        \subitem Wie viel lässt sich mit diesem Tool möglichst einfach und
        schnell erreichen? Ist besonders viel Vorarbeit notwendig um die Tests
        auf zu setzen oder kann sofort mit dem Schreiben der Tests begonnen
        werden?
        \newline
        \\
        Genauso stellt sich die Frage, wie Effizient der Entwickler die Tests
        auswerten kann.
    \item Komplexität
        \subitem Wie komplex ist das Tool? Das heißt, wie viel Funktionalität
        bietet das Tool dem Entwickler von Haus aus, aber auch wie schwer
        ist es einen Code zu schreiben oder wie schnell wird ein Code unübersichtlich, da
        das Tool viel Code abseits der Tests benötigt.
    \item Erweiterbarkeit
        \subitem Wie leicht lässt sich das Tool mit anderen Tools erweitern?
        Gibt es vielleicht Erweiterungen der Community für dieses Tool, die sehr
        hilfreich sind?
\end{itemize}
Eventuell werden beim Schreiben der Arbeit weitere Aspekte entstehen, die hier
aufgeführt werden können.
\newline
\\
Der Vergleich der Tools entsteht durch das Analysieren dieser auf der
jeweiligen Website, sowie durch ein komplexes Code-Beispiel, das mit dem
jeweiligen Tool geschrieben wird. Passend zum Code-Beispiel wird auch analysiert,
wie einfach die Automatisierung mit Travis CI verläuft, indem dies auch mit einem
echtem Code getestet wird.

Sind die Grundlagen für den Vergleich geschaffen, werden die Tools
untereinander verglichen und ihre Schwächen und Stärken noch zusammen
gefasst.
\newline
\\
Sofern dies möglich ist wird versucht die Tools zu kombinieren um etwaige
Schwächen eines Tools zu auszugleichen.

Nachdem das/die beste(n) Tool(s) gefunden wurde(n), wird auf die Schwächen von TDD
im Allgemeinen eingegangen. Dies behandelt den erforderlichen Aufwand und die
daraus resultierende Zeit, die "verloren" geht (Zeit, die statt für Tests
schreiben auch für Code schreiben genutzt werden könnte), sowie die Disziplin,
die den Entwicklern abverlangt wird, zuerst Tests zu schreiben, bevor die
tatsächliche Funktionalität geschrieben wird. Es wird auch auf den
Wirtschaftlichen Einsatz von TDD eingegangen.

Am Ende der Arbeit nehme ich selbst Stellung zu der Effizienz, Funktionalität und positiven, sowie negativen Aspekten zu TDD. Außerdem gebe ich eine Empfehlung ab, für wen TDD am Besten von Nutzen ist.
